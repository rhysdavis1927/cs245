/* Generated By:JavaCC: Do not edit this line. Assignment.java */
import java.io.*;
import java.util.ArrayList;
import java.util.Collections;

public class Assignment implements AssignmentConstants {
  //An arraylist that keeps track of locations declared  static ArrayList < Location > locations = new ArrayList < Location > ();

  static float [] [] northSouthDistances; //records the north/south distances between locations
  static float [] [] eastWestDistances; //records the east/west distances between locations
  public static void main(String args []) throws ParseException
  {
    Assignment parser = new Assignment(System.in);
    try
    {
      parser.Start();
    }
    catch (ParseException e)
    {
      System.out.println("[PARSING ERROR] " + "Input sentence not valid in language grammar.");
    }
    catch (TokenMgrError e)
    {
      System.err.println("[LEXING ERROR]" + "Disallowed character entered");
    }
  }

  static final public void Start() throws ParseException {
    Declaration();
    label_1:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMI_COLON:
        jj_consume_token(SEMI_COLON);
        break;
      case FULL_STOP:
        jj_consume_token(FULL_STOP);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Declaration();
    }
    /*
      * The array of locations is sorted, then two arrays are created for the north/south
      * and east/west distance between two locations. A method is then called to initialise
      * these arrays;
      */
    Collections.sort(locations);
    northSouthDistances = new float [ locations.size() ] [ locations.size() ];
    eastWestDistances = new float [ locations.size() ] [ locations.size() ];
    InitialiseArrays();
    label_2:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMI_COLON:
        jj_consume_token(SEMI_COLON);
        break;
      case FULL_STOP:
        jj_consume_token(FULL_STOP);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Relation();
    }
    jj_consume_token(FULL_STOP);
    jj_consume_token(0);
    PrintDistances();
  }

  static final public void Declaration() throws ParseException {
  Token t;
  String str;
    jj_consume_token(I_SEE);
    jj_consume_token(THE);
    str = Location();
    //If the location has already been declared then a parse exception
    //will be thrown.
    try
    {
      if (locations.contains(new Location(str)))
      {
        {if (true) throw new ParseException("[PARSING ERROR] Location declared twice");}
      }
    }
    catch (ParseException e)
    {
      System.out.println(e.getMessage());
      System.exit(1);
    }
    //Add the declared location to the list of locations 
    locations.add(new Location(str));
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONNECTIVE:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      jj_consume_token(CONNECTIVE);
      jj_consume_token(THE);
      str = Location();
      try
      {
        if (locations.contains(new Location(str)))
        {
          {if (true) throw new ParseException("[PARSING ERROR] Location declared twice");}
        }
      }
      catch (ParseException e)
      {
        System.out.println(e.getMessage());
        System.exit(1);
      }
      locations.add(new Location(str));
    }
  }

  static final public void Relation() throws ParseException {
  Token tok;
  String str;
  ArrayList < Integer > indexArrayA = new ArrayList < Integer > ();
  ArrayList < Integer > indexArrayB = new ArrayList < Integer > ();
  float distance = 0;
  String direction;
    jj_consume_token(THE);
    str = Location();
    //The declared function checks to see that the location
    //has already been declared and returns the index of the
    //location if it has. This index is then added to the array.
    indexArrayA.add(Declared(str));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS:
      jj_consume_token(IS);
      break;
    case CONNECTIVE:
      label_4:
      while (true) {
        jj_consume_token(CONNECTIVE);
        jj_consume_token(THE);
        str = Location();
          indexArrayA.add(Declared(str));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONNECTIVE:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_4;
        }
      }
      jj_consume_token(ARE);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      distance = Distance();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NORTH:
      tok = jj_consume_token(NORTH);
      break;
    case SOUTH:
      tok = jj_consume_token(SOUTH);
      break;
    case EAST:
      tok = jj_consume_token(EAST);
      break;
    case WEST:
      tok = jj_consume_token(WEST);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    direction = tok.toString();
    jj_consume_token(THE);
    str = Location();
    indexArrayB.add(Declared(str));
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONNECTIVE:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_5;
      }
      jj_consume_token(CONNECTIVE);
      jj_consume_token(THE);
      str = Location();
      indexArrayB.add(Declared(str));
    }
    /*
    *For each of the numbers in indexArrayA we check to see if it is also in
    *indexArrayB. If so then we are trying to relate a  location to itself
    *so an exception is thrown.
    *Then for each number in indexArrayB we record the distance between them.
    *We then call a method to set the relation between the two locations.
    */
    for (Integer i : indexArrayA)
    {
      try
      {
        if (indexArrayB.contains(i))
        {
          {if (true) throw new ParseException("[PARSING ERROR] Cannot relate a location to itself");}
        }
      }
      catch (ParseException e)
      {
        System.err.println(e.getMessage());
        System.exit(1);
      }
      for (int j : indexArrayB)
      {
        if (direction.equals("north of") || direction.equals("south of"))
        {
          northSouthDistances [ i ] [ j ] = distance;
          northSouthDistances [ j ] [ i ] = distance;
        }
        else
        {
          eastWestDistances [ i ] [ j ] = distance;
          eastWestDistances [ j ] [ i ] = distance;
        }
        setRelation(i, j, direction);
      }
    }
  }

//Takes two numbers which are the index of two locations//in the locations array and the direction and sets up the relation//between these two locations and adds any consequent relations.  static final public void setRelation(int i, int j, String direction) throws ParseException {
  ArrayList < Integer > newIndexArray = new ArrayList < Integer > ();
  Location a;
  Location b;
    if (direction.equals("north of") || direction.equals("south of"))
    {
      //Since a is north of b is equivalent to b is south of a, we use
      //the same code for north and south relations but with the locations
      //swapped around.
      if (direction.equals("north of"))
      {
        a = locations.get(i);
        b = locations.get(j);
      }
      else
      {
        a = locations.get(j);
        b = locations.get(i);
      }
      //If b is already north of a then we cannot set a to be north of b
      //so an exception is thrown
      try
      {
        if (b.northOf.contains(a.getName()))
        {
          {if (true) throw new ParseException("[SEMANTIC ERROR] " + a.getName() + " cannot be both north and south of " + b.getName());}
        }
      }
      catch (ParseException e)
      {
        System.out.println(e.getMessage());
        System.exit(1);
      }
      //Check to make sure this relation has not already been added.
      if (!a.northOf.contains(b.getName()))
      {
        a.northOf.add(b.getName()); //add b to the list of locations that a is north of
        newIndexArray.clear();
        //We take the index of all the locations that b is north of
        for (String s : b.northOf)
        {
          newIndexArray.add(locations.indexOf(new Location(s)));
        }

        //Now for each of these locations we set the relation that a is also north
        //of these locations. This is due to the transitivity of the relation.
        for (int k : newIndexArray)
        {
          setRelation(i, k, "north of");
        }
      }
      if (!b.southOf.contains(a.getName()))
      {
        newIndexArray.clear();
        b.southOf.add(a.getName());     //Add a to the list of locations that b is south of
        //Take the index of all locations that a is south of.
        for (String s : a.southOf)
        {
          newIndexArray.add(locations.indexOf(new Location(s)));
        }

        //Set all these locations to be south of location b. Again this due to the
        //transitivity of the relation.
        for (int k : newIndexArray)
        {
          setRelation(j, k, "south of");
        }
      }
    }
    else if (direction.equals("east of") || direction.equals("west of"))
    {
      //Since a is east of b is equivalent to b is west of a, we use
      //the same code for east and west relations but with the locations
      //swapped around.
      if (direction.equals("east of"))
      {
        a = locations.get(i);
        b = locations.get(j);
      }
      else
      {
        a = locations.get(j);
        b = locations.get(i);
      }
      //If b is already east of a then we cannot set a to be west of b
      //so an exception is thrown
      try
      {
        if (b.eastOf.contains(a.getName()))
        {
          {if (true) throw new ParseException("[SEMANTIC ERROR] " + a.getName() + " cannot be both east and west of " + b.getName());}
        }
      }
      catch (ParseException e)
      {
        System.out.println(e.getMessage());
        System.exit(1);
      }

      //Check to make sure this relation has not already been added.
      if (!a.eastOf.contains(b.getName()))
      {
        a.eastOf.add(b.getName());      //add b to the list of locations that a is east of
        newIndexArray.clear();

        //We take the index of all the locations that b is east of
        for (String s : b.eastOf)
        {
          newIndexArray.add(locations.indexOf(new Location(s)));
        }

        //Now for each of these locations we set the relation that a is also east
        //of these locations. This is due to the transitivity of the relation.
        for (int k : newIndexArray)
        {
          setRelation(i, k, "east of");
        }
      }
      if (!b.westOf.contains(a.getName()))
      {
        newIndexArray.clear();
        b.westOf.add(a.getName());      //Add a to the list of locations that b is west of
        //Take the index of all locations that a is west of.
        for (String s : a.westOf)
        {
          newIndexArray.add(locations.indexOf(new Location(s)));
        }

        //Set all these locations to be west of location b. Again this due to the
        //transitivity of the relation.
        for (int k : newIndexArray)
        {
          setRelation(j, k, "west of");
        }
      }
    }
  }

  static final public int Declared(String str) throws ParseException {
  int i;
    i = locations.indexOf(new Location(str));
    try
    {
      if (i == - 1)
      {
        {if (true) throw new ParseException("[PARSING ERROR] Undeclared location");}
      }
      else {if (true) return i;}
    }
    catch (ParseException e)
    {
      System.out.println(e.getMessage());
      System.exit(1);
    }
    throw new Error("Missing return statement in function");
  }

  static final public String Location() throws ParseException {
  Token t;
  String str = "";
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      t = jj_consume_token(LOCATION_PART);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RBRACE:
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      str += t.toString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case LOCATION_PART:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_6;
      }
    }
    {if (true) return str.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

/** The arrays are initialised with 0 distance between a location and itself and -1* distance between all the rest. I have chose -1 to recognise which locations do not* have a distance between them defined . */
  static final public void InitialiseArrays() throws ParseException {
    for (int i = 0; i < locations.size(); i++)
    {
      for (int j = 0; j < locations.size(); j++)
      {
        if (i == j)
        {
          northSouthDistances [ i ] [ j ] = 0;
          eastWestDistances [ i ] [ j ] = 0;
        }
        else
        {
          northSouthDistances [ i ] [ j ] = - 1;
          eastWestDistances [ i ] [ j ] = - 1;
        }
      }
    }
  }

//Prints out a matrix of distances between locations as described in spec   static final public void PrintDistances() throws ParseException {
    System.out.println("Distances:");
    for (Location l : locations)
    {
      System.out.print("\u005ct");
      System.out.print(l.getName());
    }
    System.out.println("");
    for (int i = 0; i < locations.size(); i++)
    {
      System.out.print(locations.get(i).getName());
      System.out.print("\u005ct");
      for (int j = 0; j < locations.size(); j++)
      {
        if (northSouthDistances [ i ] [ j ] == - 1 || eastWestDistances [ i ] [ j ] == - 1)
        {
          if (i == j)
          {
            //distance between location and itself is 0
            System.out.print(northSouthDistances [ i ] [ j ]);
            System.out.print("\u005ct");
          }
          else
          {
            //if we we not know either the north/south or the east/west distance
            //then the distance is unkown
            System.out.print("unkown");
            System.out.print("\u005ct");
          }
        }
        else
        {
          //Manhattan distance calculated by adding the north/south distance and the
          //east/west distance.
          System.out.print(northSouthDistances [ i ] [ j ] + eastWestDistances [ i ] [ j ]);
          System.out.print("\u005ct");
        }
      }
      System.out.println();
    }
  }

  static final public float Distance() throws ParseException {
  Token number;
  Token unit;
  float distance;
    number = jj_consume_token(NUMBER);
    unit = jj_consume_token(UNIT);
    //Takes the number given by the token and converts it to float
    //then checks the unit given and converts to meters if
    //necessary and returns the value
    if (unit.toString().equals("miles"))
    {
      distance = Float.valueOf(number.toString()) * 1609;
    }
    else if (unit.toString().equals("km"))
    {
      distance = Float.valueOf(number.toString()) * 1000;
    }
    else
    {
      distance = Float.valueOf(number.toString());
    }
    {if (true) return distance;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_3R_7() {
    if (jj_scan_token(I_SEE)) return true;
    return false;
  }

  static private boolean jj_3R_8() {
    if (jj_scan_token(THE)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) return true;
    }
    if (jj_3R_8()) return true;
    return false;
  }

  static private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) return true;
    }
    if (jj_3R_7()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AssignmentTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[11];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x6000,0x6000,0x8000,0x8000,0x8080,0x10000,0x1e00,0x8000,0x40000,0x100000,0xc0000,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[2];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Assignment(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Assignment(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AssignmentTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Assignment(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AssignmentTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Assignment(AssignmentTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(AssignmentTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 11; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[21];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 11; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 21; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class Location implements Comparable < Location >
{
  //Each location has a name and ArrayLists containing the names of  //the locations that they are north, south, east and west of.    private String name;
  ArrayList < String > northOf;
  ArrayList < String > eastOf;
  ArrayList < String > southOf;
  ArrayList < String > westOf;

  Location(String name)
  {
    this.name = name;
    northOf = new ArrayList < String > ();
    eastOf = new ArrayList < String > ();
    southOf = new ArrayList < String > ();
    westOf = new ArrayList < String > ();
  }

  //Overides compareTo method in Comparable  //compares locations by comparing their names  public int compareTo(Location a)
  {
    return this.name.compareTo(a.name);
  }

  public String getName()
  {
    return this.name;
  }

  //A location is the same as another if they have  //the same name.  public boolean equals(Object b)
  {
    return this.name.equals(((Location) b).name);
  }
}
