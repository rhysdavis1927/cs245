options{  //Make lexer case insensitive  IGNORE_CASE = true;}PARSER_BEGIN(Assignment)import java.io.*;import java.util.ArrayList;import java.util.Collections;public class Assignment{  //An arraylist that keeps track of locations declared  static ArrayList < Location > locations = new ArrayList < Location > ();  static float [] [] northSouthDistances; //records the north/south distances between locations  static float [] [] eastWestDistances; //records the east/west distances between locations  public static void main(String args []) throws ParseException  {    Assignment parser = new Assignment(System.in);    try    {      parser.Start();    }    catch (ParseException e)    {      System.out.println("[PARSING ERROR] " + "Input sentence not valid in language grammar.");    }    catch (TokenMgrError e)    {      System.err.println("[LEXING ERROR]" + "Disallowed character entered");    }  }}class Location implements Comparable < Location >{  //Each location has a name and ArrayLists containing the names of  //the locations that they are north, south, east and west of.    private String name;  ArrayList < String > northOf;  ArrayList < String > eastOf;  ArrayList < String > southOf;  ArrayList < String > westOf;    Location(String name)  {    this.name = name;    northOf = new ArrayList < String > ();    eastOf = new ArrayList < String > ();    southOf = new ArrayList < String > ();    westOf = new ArrayList < String > ();  }  //Overides compareTo method in Comparable  //compares locations by comparing their names  public int compareTo(Location a)  {    return this.name.compareTo(a.name);  }  public String getName()  {    return this.name;  }  //A location is the same as another if they have  //the same name.  public boolean equals(Object b)  {    return this.name.equals(((Location) b).name);  }}PARSER_END(Assignment)//White space that will be ignored by the parser
<* >SKIP :{  " "| "\t"| "\n"| "\r"}TOKEN :{  //Keywords of the language  < I_SEE : "I See" >| < THE : "The" >| < IS : "is" >| < ARE : "are" >| < NORTH : "north of" >| < EAST : "east of" >| < SOUTH : "south of" >| < WEST : "west of" >}TOKEN :{  //separators  < SEMI_COLON : ";" >| < FULL_STOP : "." >| < CONNECTIVE :    //"and" & "," will be treated equally so are classed as a connective    "and"  | "," >}TOKEN :{  //Number allows the user to enter a decimal number for the distance  < NUMBER :    ([ "0"-"9" ])+  | ([ "0"-"9" ])+ "." ([ "0"-"9" ])+ >  //Unit is the unit of measurement of the distance| < UNIT :    "miles"  | "km"  | "m" >  //If LBRACE token is matched the the lexical state changes to LOCATION_STATE| < LBRACE : "[" > : LOCATION_STATE}//LOCATION_PART is recognised in the default lexical state and is one of//only two tokens in the LOCATION_STATE lexical state. This allows you to//use location names inside braces that may have been confused with keywords.< DEFAULT, LOCATION_STATE >TOKEN :{  < LOCATION_PART : ([ "a"-"z" ])+ >}//If the lexical state is LOCATION_STATE then the RBRACE token//can be matched. If it is matched then the lexical state returns//to the default state.< LOCATION_STATE >TOKEN :{  < RBRACE : "]" > : DEFAULT}void Start() :{}{  //Starts with a declaration of a location  (    Declaration()  )  //Look ahead of 2 is used because if next token was  //a semi-colon or full stop this doesn't give enough information  //to make a choice. So if we look at the next token we can see  //which choice to make.  (    LOOKAHEAD(2)    (      < SEMI_COLON >    | < FULL_STOP >    )    Declaration()  )*  {    /*      * The array of locations is sorted, then two arrays are created for the north/south      * and east/west distance between two locations. A method is then called to initialise      * these arrays;      */    Collections.sort(locations);    northSouthDistances = new float [ locations.size() ] [ locations.size() ];    eastWestDistances = new float [ locations.size() ] [ locations.size() ];    InitialiseArrays();  }  //Look ahead of 2 is used because if next token was  //a full stop this doesn't give enough information to   //make a choice. So if we look at the next token we can   //see which choice to make.  (    LOOKAHEAD(2)    (      < SEMI_COLON >    | < FULL_STOP >    )    Relation()  )*  //Always ends with a full stop and then the end of file  < FULL_STOP > < EOF >       PrintDistances()      //Calls a method to print the distances between locations}void Declaration() :{  Token t;  String str;}{  //Match tokens, str is set to the returned value of the Location() function  //which is a String containing the name of the location being declared.  < I_SEE > < THE > str = Location()  {    //If the location has already been declared then a parse exception    //will be thrown.    try    {      if (locations.contains(new Location(str)))      {        throw new ParseException("[PARSING ERROR] Location declared twice");      }    }    catch (ParseException e)    {      System.out.println(e.getMessage());      System.exit(1);    }    //Add the declared location to the list of locations     locations.add(new Location(str));  }  //Takes any further declarations and stores it in the array  //or throws an exception if already declared.  (    < CONNECTIVE > < THE > str = Location()    {      try      {        if (locations.contains(new Location(str)))        {          throw new ParseException("[PARSING ERROR] Location declared twice");        }      }      catch (ParseException e)      {        System.out.println(e.getMessage());        System.exit(1);      }      locations.add(new Location(str));    }  )*}void Relation() :{  Token tok;  String str;  ArrayList < Integer > indexArrayA = new ArrayList < Integer > ();  ArrayList < Integer > indexArrayB = new ArrayList < Integer > ();  float distance = 0;  String direction;}{  < THE > str = Location()  {    //The declared function checks to see that the location    //has already been declared and returns the index of the    //location if it has. This index is then added to the array.    indexArrayA.add(Declared(str));  }  (    < IS >  |    (      (        < CONNECTIVE > < THE > str = Location()        {          indexArrayA.add(Declared(str));        }      )+      < ARE >    )  )  //optional distance. If user enters a number and a unit the Distance() method  //converts the distance to metres and result is stored in the variable distance.  (    distance = Distance()  )?  (    tok = < NORTH >  | tok = < SOUTH >  | tok = < EAST >  | tok = < WEST >  )  {    direction = tok.toString();  }  < THE > str = Location()  {    indexArrayB.add(Declared(str));  }  (    < CONNECTIVE > < THE > str = Location()    {      indexArrayB.add(Declared(str));    }  )*  {    /*    *For each of the numbers in indexArrayA we check to see if it is also in    *indexArrayB. If so then we are trying to relate a  location to itself    *so an exception is thrown.    *Then for each number in indexArrayB we record the distance between them.    *We then call a method to set the relation between the two locations.    */    for (Integer i : indexArrayA)    {      try      {        if (indexArrayB.contains(i))        {          throw new ParseException("[PARSING ERROR] Cannot relate a location to itself");        }      }      catch (ParseException e)      {        System.err.println(e.getMessage());        System.exit(1);      }      for (int j : indexArrayB)      {        if (direction.equals("north of") || direction.equals("south of"))        {          northSouthDistances [ i ] [ j ] = distance;          northSouthDistances [ j ] [ i ] = distance;        }        else        {          eastWestDistances [ i ] [ j ] = distance;          eastWestDistances [ j ] [ i ] = distance;        }        setRelation(i, j, direction);      }    }  }}//Takes two numbers which are the index of two locations//in the locations array and the direction and sets up the relation//between these two locations and adds any consequent relations.void setRelation(int i, int j, String direction) :{  ArrayList < Integer > newIndexArray = new ArrayList < Integer > ();  Location a;  Location b;}{  {    if (direction.equals("north of") || direction.equals("south of"))    {      //Since a is north of b is equivalent to b is south of a, we use      //the same code for north and south relations but with the locations      //swapped around.      if (direction.equals("north of"))      {        a = locations.get(i);        b = locations.get(j);      }      else      {        a = locations.get(j);        b = locations.get(i);      }      //If b is already north of a then we cannot set a to be north of b      //so an exception is thrown      try      {        if (b.northOf.contains(a.getName()))        {          throw new ParseException("[SEMANTIC ERROR] " + a.getName() + " cannot be both north and south of " + b.getName());        }      }      catch (ParseException e)      {        System.out.println(e.getMessage());        System.exit(1);      }      //Check to make sure this relation has not already been added.      if (!a.northOf.contains(b.getName()))      {        a.northOf.add(b.getName()); //add b to the list of locations that a is north of        newIndexArray.clear();        //We take the index of all the locations that b is north of        for (String s : b.northOf)        {          newIndexArray.add(locations.indexOf(new Location(s)));        }                //Now for each of these locations we set the relation that a is also north        //of these locations. This is due to the transitivity of the relation.        for (int k : newIndexArray)        {          setRelation(i, k, "north of");        }      }      if (!b.southOf.contains(a.getName()))      {        newIndexArray.clear();        b.southOf.add(a.getName());     //Add a to the list of locations that b is south of        //Take the index of all locations that a is south of.        for (String s : a.southOf)        {          newIndexArray.add(locations.indexOf(new Location(s)));        }        //Set all these locations to be south of location b. Again this due to the        //transitivity of the relation.        for (int k : newIndexArray)        {          setRelation(j, k, "south of");        }      }    }    else if (direction.equals("east of") || direction.equals("west of"))    {      //Since a is east of b is equivalent to b is west of a, we use      //the same code for east and west relations but with the locations      //swapped around.      if (direction.equals("east of"))      {        a = locations.get(i);        b = locations.get(j);      }      else      {        a = locations.get(j);        b = locations.get(i);      }      //If b is already east of a then we cannot set a to be west of b      //so an exception is thrown      try      {        if (b.eastOf.contains(a.getName()))        {          throw new ParseException("[SEMANTIC ERROR] " + a.getName() + " cannot be both east and west of " + b.getName());        }      }      catch (ParseException e)      {        System.out.println(e.getMessage());        System.exit(1);      }      //Check to make sure this relation has not already been added.      if (!a.eastOf.contains(b.getName()))      {        a.eastOf.add(b.getName());      //add b to the list of locations that a is east of        newIndexArray.clear();        //We take the index of all the locations that b is east of        for (String s : b.eastOf)        {          newIndexArray.add(locations.indexOf(new Location(s)));        }                //Now for each of these locations we set the relation that a is also east        //of these locations. This is due to the transitivity of the relation.        for (int k : newIndexArray)        {          setRelation(i, k, "east of");        }      }      if (!b.westOf.contains(a.getName()))      {        newIndexArray.clear();        b.westOf.add(a.getName());      //Add a to the list of locations that b is west of        //Take the index of all locations that a is west of.        for (String s : a.westOf)        {          newIndexArray.add(locations.indexOf(new Location(s)));        }        //Set all these locations to be west of location b. Again this due to the        //transitivity of the relation.        for (int k : newIndexArray)        {          setRelation(j, k, "west of");        }      }    }  }}int Declared(String str) :{  int i;}{  //Looks for the given string in the array. If found returns the index  //of location, if not then throws a parse exception.  {    i = locations.indexOf(new Location(str));    try    {      if (i == - 1)      {        throw new ParseException("[PARSING ERROR] Undeclared location");      }      else return i;    }    catch (ParseException e)    {      System.out.println(e.getMessage());      System.exit(1);    }  }}String Location() :{  Token t;  String str = "";}{  (    //Takes string given by a location part and concatenates    //with the string given by any following location parts to    //build up a full location name.    //The full string is then converted to lower case and returned.    (< LBRACE >)? t = < LOCATION_PART > (< RBRACE >)?    {      str += t.toString();    }  )+  {    return str.toLowerCase();  }}/** The arrays are initialised with 0 distance between a location and itself and -1* distance between all the rest. I have chose -1 to recognise which locations do not* have a distance between them defined . */void InitialiseArrays() :{}{  {    for (int i = 0; i < locations.size(); i++)    {      for (int j = 0; j < locations.size(); j++)      {        if (i == j)        {          northSouthDistances [ i ] [ j ] = 0;          eastWestDistances [ i ] [ j ] = 0;        }        else        {          northSouthDistances [ i ] [ j ] = - 1;          eastWestDistances [ i ] [ j ] = - 1;        }      }    }  }}//Prints out a matrix of distances between locations as described in spec void PrintDistances() :{}{  {    System.out.println("Distances:");    for (Location l : locations)    {      System.out.print("\t");      System.out.print(l.getName());    }    System.out.println("");    for (int i = 0; i < locations.size(); i++)    {      System.out.print(locations.get(i).getName());      System.out.print("\t");      for (int j = 0; j < locations.size(); j++)      {        if (northSouthDistances [ i ] [ j ] == - 1 || eastWestDistances [ i ] [ j ] == - 1)        {          if (i == j)          {            //distance between location and itself is 0            System.out.print(northSouthDistances [ i ] [ j ]);            System.out.print("\t");          }          else          {            //if we we not know either the north/south or the east/west distance            //then the distance is unkown            System.out.print("unkown");            System.out.print("\t");          }        }        else        {          //Manhattan distance calculated by adding the north/south distance and the          //east/west distance.          System.out.print(northSouthDistances [ i ] [ j ] + eastWestDistances [ i ] [ j ]);          System.out.print("\t");        }      }      System.out.println();    }  }}float Distance() :{  Token number;  Token unit;  float distance;}{  number = < NUMBER > unit = < UNIT >  {    //Takes the number given by the token and converts it to float    //then checks the unit given and converts to meters if    //necessary and returns the value    if (unit.toString().equals("miles"))    {      distance = Float.valueOf(number.toString()) * 1609;    }    else if (unit.toString().equals("km"))    {      distance = Float.valueOf(number.toString()) * 1000;    }    else    {      distance = Float.valueOf(number.toString());    }    return distance;  }}